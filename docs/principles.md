- **No legacy support.** The project evolves rapidly, and every release may remove older code paths. We do not carry shims for prior layouts, schemas, or CLIs; fixes should update the latest design instead of preserving history.
- **Fast failures beat silent fallbacks.** When required files are missing or malformed, commands must exit with actionable errors rather than auto-healing. Any fallback that masks user mistakes should be treated as a bug.
- **One source of truth for workspace layout.** Keep workspace contracts (directory paths, schema types) defined in reusable modules so every command and strategy consumes the same definition. Avoid hardcoding paths or structures inside individual commands.
- **Thin command logic.** Keep CLI modules focused on orchestration and defer reusable behavior to shared utilities in `src/utils/` (or other dedicated modules). When functionality could be reused, extract it rather than duplicating inside command handlers.
- **Intentional module ordering.** Arrange exports within a module from public API to helpers, grouping related functions/classes together. This makes it easier to discover entry points and encourages consistent structure across files.
- **Consistency over convenience.** Favor predictable patterns in code, configuration, docs, and CLI outputâ€”even when it means a little extra work. Shared conventions (argument ordering, naming, file layout) keep the system discoverable and make regressions easier to spot.
